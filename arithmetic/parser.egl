import lexer.egl
import expressions.egl
import stacks.egl
import ../utils/string.egl
import ../utils/stdlib.egl

export *

func prec(Token t) : int
{
    if t == Sentinel
        return 0
    if t == Plus || t == Minus
        return 1
    if t == Mult || t == Div
        return 2
    if t == ParenL
        return 100

    return 0
}

func parse(byte* str) : Expression^
{
    var lexer = new Lexer(str)
    var operands = new PointerStack()
    var operators = new TokenStack()
    operators^.push(Sentinel)

    for lexer^.valid()
    {
        var tok = lexer^.next()

        if tok == Number
        {
            operands^.push(new Value(atof(lexer^.buffer)))
        }
        elif tok == ParenR
        {
            for operators^.top() != ParenL
            {
                var top = operators^.pop()
                Expression^ a = operands^.pop()
                Expression^ b = operands^.pop()
                operands^.push(new BinaryOp(b, a, top))
            }
            operators^.pop()
        }
        else
        {
            var top = operators^.top()

            for prec(tok) <= prec(top) && top != ParenL
            {
                operators^.pop()
                Expression^ a = operands^.pop()
                Expression^ b = operands^.pop()
                operands^.push(new BinaryOp(b, a, top))

                top = operators^.top()
            }

            operators^.push(tok)
        }
    }

    for operators^.top() != Sentinel
    {
        Expression^ a = operands^.pop()
        Expression^ b = operands^.pop()

        operands^.push(new BinaryOp(b, a, operators^.pop()))
    }

    return operands^.pop()
}

