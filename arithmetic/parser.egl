import lexer.egl
import expressions.egl
import stacks.egl
import ../utils/string.egl
import ../utils/stdlib.egl
import ../utils/misc.egl

export *

struct ParserHelper
{
    PointerStack^ operands
    TokenStack^   operators
    Token         tok
    Lexer^        lexer
}

enum Precedence
{
    Zero
    VeryLow
    Low
    Medium
    High
    VeryHigh
    VeryVeryHigh
    ExtremelyHigh
}

enum Associativity
{
    Left
    Right
}

func parse(byte* str) : Expression^
{
    var lexer = new Lexer(str)
    var operands = new PointerStack()
    var operators = new TokenStack()

    ParserHelper h
    h.operators = operators
    h.operands = operands
    h.lexer = lexer

    operators.push(Sentinel)

    for lexer.valid()
    {
        var tok = lexer.next()
        h.tok = tok

        if tok == Number
            operands.push(new Value(atof(lexer.buffer)))
        elif tok == Identifier && !strcmp(lexer.buffer, 'x')
        {
            var val = new Value(0.0)
            val.isvar = yes
            operands.push(val)
        }
        elif tok == Identifier
            ph_handle_function(&h)
        elif tok == ParenR
            ph_paren_r(&h)
        else
            ph_handle_infix(&h)
    }

    for operators.top() != Sentinel
    {
        ph_map_operator(&h)
    }

    return operands.pop()
}

func ph_handle_function(ParserHelper* h)
{
    var buf = h.lexer.buffer
    var f   = BuiltinFunction.Invalid
    if   strequ(buf, 'Sin'); f = Sin
    elif strequ(buf, 'Cos'); f = Cos
    elif strequ(buf, 'Tan'); f = Tan
    elif strequ(buf, 'Abs'); f = Abs
    elif strequ(buf, 'ArcSin'); f = ArcSin
    elif strequ(buf, 'ArcCos'); f = ArcCos
    elif strequ(buf, 'ArcTan'); f = ArcTan

    if f == Invalid
    {
        0 -- TODO: Error...
    }

    h.operators.push(Token@f)
}

-*
 * ph_ for parser_handle...
 * Deal with the right parenthesis
 *-
func ph_paren_r(ParserHelper* h)
{
    for h.operators.top() != ParenL
    {
        ph_map_operator(h)
    }
    h.operators.pop()

    if h.operators.top() > Builtin -- We have a function on the stack
    {
        var val = h.operands.pop()
        var f   = BuiltinFunction@h.operators.pop()
        h.operands.push(new FunctionCall(val, f))
    }
}

-*
 * Deal with infix operators (assumes left associative)
 *-
func ph_handle_infix(ParserHelper* h)
{
    var operators = h.operators
    var operands  = h.operands
    var tok = h.tok

    var top = operators.top()

    for ph_needs_pop(tok, top) && top != ParenL
    {
        ph_map_operator(h)
        top = operators.top()
    }

    operators.push(tok)
}

func ph_map_operator(ParserHelper* h)
{
    var top = h.operators.pop()
    if is_binary_operator(top) -- If we are dealing with a binary operator
    {
        Expression^ a = h.operands.pop()
        Expression^ b = h.operands.pop()
        h.operands.push(new BinaryOp(b, a, top))
    }
    elif is_unary_operator(top)
    {
        Expression^ a = h.operands.pop()
        h.operands.push(new UnaryOp(a, top))
    }
}

func ph_needs_pop(Token tok, Token top) : bool
{
    if ph_associativity(tok) == Left
        return prec(tok) <= prec(top)

    return prec(tok) < prec(top)
}

func ph_associativity(Token tok) : Associativity
{
    if tok == UMinus || tok == Pow
        return Right

    return Left
}

-*
 * Returns a relative precedence associated with
 * the given token
 *-
func prec(Token t) : Precedence
{
    if t == Sentinel
        return Zero
    if t == Plus || t == Minus
        return Low
    if t == Mult || t == Div
        return Medium
    if t == UMinus
        return VeryHigh
    if t == Pow
        return VeryVeryHigh
    if t == ParenL
        return ExtremelyHigh

    return Zero
}

