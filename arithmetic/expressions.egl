import lexer.egl
import values.egl
import scope.egl
import ../utils/math.egl
import ../utils/stdlib.egl
import ../utils/misc.egl
import ../utils/hashtable.egl
import ../utils/arraylist.egl

export (class) '*'

export
interface Expression
{
    func eval(double) : InterpValue^
    func render() : byte*
    func set(InterpValue^)
}

export
enum BuiltinFunction
{
    Invalid : 100 -- Start where Token ends
    Sin
    Cos
    Tan
    ArcSin
    ArcCos
    ArcTan
    Abs
    Log
    Ln
    Sqrt

    TwoParam : 200 -- Start Two Parameter Functions
    LogB
    Rand
    Min
    Max

    NParam : 1000  -- User-defined functions
}

class FunctionCall (Expression)
{
    Arraylist^ values
    BuiltinFunction f

    init(BuiltinFunction f, Arraylist^ values)
    {
        self.values = values
        self.f = f
    }

    func eval(double v) : InterpValue^
    {
        if self.f < NParam
            return new NumberValue(self.evalNumeric(v))



        -*
        var scope = get_global_scope_manager()
        scope.push()

        for int i = 0; i < self.values.count; i += 1
        {
            String^ str = 
            scope.set(self.values
        }
        *-

        return nil
    }

    func evalNumeric(double x) : double
    {
        double v
        double v2

        Expression^ val1 = self.values.get(0)
        v = val1.eval(x).asNumber()

        if self.values.count > 1
        {
            Expression^ val2 = self.values.get(1)
            v2 = val2.eval(x).asNumber()
        }

        switch self.f
        {
            case Sin;    return sin(v)
            case Cos;    return cos(v)
            case Tan;    return tan(v)
            case Abs;    return fabs(v)
            case ArcSin; return asin(v)
            case ArcCos; return acos(v)
            case ArcTan; return atan(v)
            case Ln;     return log(v)
            case Log;    return log(v) / log(10)
            case Sqrt;   return sqrt(v)
            case LogB;   return log(v2) / log(v)
            case Rand;   return rand_range(v, v2)
            case Min;    return min(v, v2)
            case Max;    return max(v, v2)
        }

        return 0
    }

    func render() : byte*
    {
        return nil
    }

    func set(InterpValue^ x)
    {
        x
        puts 'Error: Cannot set expression type'
    }
}

class UnaryOp (Expression)
{
    Expression^ value

    Token op

    init(Expression^ value, Token op)
    {
        self.value = value
        self.op = op
    }

    func eval(double x) : InterpValue^
    {
        var val = self.value.eval(x)
        if val.type() != Number
            return nil

        double v = self.value.eval(x).asNumber()
        Token op = self.op

        if op == UMinus; return new NumberValue(-v)
        return nil
    }

    func render() : byte*
    {
        var v = self.value.render()
        byte b = 0
        var op = self.op
        if op == UMinus; b = `-`

        byte* me = malloc(strlen(v) + 10)
        sprintf(me, '%c%s', b, v)

        free(v)
        return me
    }

    func set(InterpValue^ x)
    {
        x
        puts 'Error: Cannot set expression type'
    }
}

class BinaryOp (Expression)
{
    Expression^ left
    Expression^ right

    Token op

    init(Expression^ left, Expression^ right, Token op)
    {
        self.left = left
        self.right = right
        self.op = op
    }

    func eval(double x) : InterpValue^
    {
        var lval = self.left.eval(x)
        var rval = self.right.eval(x)

        if lval.type() != Number || rval.type() != Number
            return nil

        double l = lval.asNumber()
        double r = rval.asNumber()
        Token op = self.op

        double num

        if op == Plus; num = l + r
        if op == Minus; num = l - r
        if op == Mult; num = l * r
        if op == Div; num = l / r
        if op == Pow; num = pow(l, r)
        if op == Equals
        {
            self.left.set(new NumberValue(r))
            return new NumberValue(r)
        }
        
        return new NumberValue(num)
    }

    func render() : byte*
    {
        var l = self.left.render()
        var r = self.right.render()

        byte b = 0
        var op = self.op
        if op == Plus; b = `+`
        if op == Minus; b = `-`
        if op == Mult; b = `*`
        if op == Div; b = `/`

        byte* me = malloc(strlen(l) + strlen(r) + 10)
        sprintf(me, '(%s %c %s)', l, b, r)

        free(l)
        free(r)
        return me
    }

    func set(InterpValue^ x)
    {
        x
        puts 'Error: Cannot set expression type'
    }
}

class Value (Expression)
{
    InterpValue^ val
    bool   isvar

    init(double val)
    {
        self.val = new NumberValue(val)
        self.isvar = no
    }

    func eval(double x) : InterpValue^
    {
        if self.isvar
            return new NumberValue(x)

        return self.val
    }

    func render() : byte*
    {
        byte* mem = malloc(20)
        sprintf(mem, '%lf', self.val)
        return mem
    }

    func set(InterpValue^ x)
    {
        x
        puts 'Error: Cannot set expression type'
    }
}

class Variable (Expression)
{
    byte* name

    init(byte* name)
    {
        self.name = strdup(name)
    }

    destruct()
    {
        free(self.name)
    }

    func eval(double x) : InterpValue^
    {
        x
        return get_global_scope_manager().lookup(self.name)
    }

    func render() : byte*
    {
        return strdup(self.name)
    }

    func set(InterpValue^ x)
    {
        get_global_scope_manager().set(self.name, x)
    }
}

export
func arg_count(BuiltinFunction f) : int
{
    if f >= NParam
        return int@f - int@BuiltinFunction.NParam
    if f > TwoParam
        return 2
    return 1
}

func rand_range(double a, double b) : double
{
    var n = min(a, b)
    var x = max(a, b)

    var diff = x - n
    var num = rand() % diff

    return n + num
}

