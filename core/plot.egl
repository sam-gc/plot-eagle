import ../utils/sdl.egl
import ../utils/stdlib.egl
import ../utils/misc.egl
import ../utils/arraylist.egl
import ../arithmetic/functions.egl

export *

extern func __egl_print_count(any^)

class Plot
{
    WindowInfo* winfo
    Surface^ surface
    Arraylist^ functions
    int mouseX
    Color backgcol

    init(WindowInfo* winfo, Surface^ surface)
    {
        self^.winfo     = winfo
        self^.surface   = surface
        self^.functions = new Arraylist(5)
        self^.mouseX    = -1
        
        memset(&self^.backgcol, 0, sizeof(Color))
    }

    func drawAxes()
    {
        double x = 0.0
        double y = 0.0

        unmap(self^.winfo, &x, &y)
        var xr = new Rect(0, short@y, self^.winfo^.width, 1)
        var yr = new Rect(short@x, 0, 1, self^.winfo^.height)

        self^.surface^.fillRect(xr, 0, 0, 255, no)
        self^.surface^.fillRect(yr, 0, 0, 255, no)
    }

    func drawFunction(Function^ f)
    {
        SDL_Rect pt
        double last = -1

        for int x in window_x_coords(self^.winfo)
        {
            double y = f^.values[x]
            unmap(self^.winfo, nil, &y)
            y = round(y)
            if y > 32767 || y < -32767
                continue

            pt.x = x
            pt.y = y
            pt.w = pt.h = 1

            if last >= 0 && !f^.discreet; connect_the_dots(&pt, last)
            self^.surface^.fillSDL_Rect(&pt, 255, 255, 255, no)

            last = y
        }
    }

    func drawFunctions()
    {
        -- TODO: If we capture `self` in the closure, self will be
        -- prematurely freed... This seems to be totally messed up
        -- weak Plot^ this = self
        -* self^.functions^.each(func(any^ item, int idx) : bool {
            this^.drawFunction(item)
            return yes
        }) *-

        for int i = 0; i < self^.functions^.count; i += 1
        {
            self^.drawFunction(self^.functions^.get(i))
        }
    }

    func addExpression(Expression^ e)
    {
        self^.functions^.append(new Function(e, self^.winfo))
    }

    func commit()
    {
        self^.surface^.flip()
    }

    func drawCrossHairs()
    {
        if self^.mouseX < 0
            return

        for int i = 0; i < self^.functions^.count; i += 1
        {
            Function^ f = self^.functions^.get(i)
            double y = f^.values[self^.mouseX]
            unmap(self^.winfo, nil, &y)
            draw_crosshairs_at(self^.surface, self^.mouseX, y, 0, 255, 255)
        }
    }

    func clear()
    {
        var back = new Rect(0, 0, self^.winfo^.width, self^.winfo^.height)
        var c = self^.backgcol
        self^.surface^.fillRect(back, c.r, c.g, c.b, no)
    }

    func render()
    {
        self^.clear()
        self^.drawAxes()
        self^.drawFunctions()
        self^.drawCrossHairs()
        self^.commit()
    }
}

func connect_the_dots(SDL_Rect* pt, double last)
{
    if pt^.y == last
        return

    double x = max(pt^.y, last)
    double n = min(pt^.y, last)

    pt^.y = n
    pt^.h = x - n
}

func draw_crosshairs_at(Surface^ s, int x, int y, byte r, byte g, byte b)
{
    SDL_Rect top
    top.x = x
    top.y = y - 5
    top.w = 1
    top.h = 5

    SDL_Rect right
    right.x = x + 1
    right.y = y
    right.w = 5
    right.h = 1

    SDL_Rect bottom
    bottom.x = x
    bottom.y = y + 1
    bottom.w = 1
    bottom.h = 5

    SDL_Rect left
    left.x = x - 5
    left.y = y
    left.w = 5
    left.h = 1

    s^.fillSDL_Rect(&top, r, g, b, no)
    s^.fillSDL_Rect(&right, r, g, b, no)
    s^.fillSDL_Rect(&left, r, g, b, no)
    s^.fillSDL_Rect(&bottom, r, g, b, no)
}


