-*
 * Expect 128,826 bytes lost (my machine) from Valgrind.
 * This loss is due to SDL, not the Eagle ref counting code.
 *-

 -- A cool plot: ./plot 1 --color 70,70,70 --static -f "-1" --color 70,70,70 --static -f "Sin(x)" --tangent --aspect --color 255,0,0 --axes-color 255,255,255 --xtick 0.78539816 --ytick 0.5 --window 1500,400 -f "Cos(x)" --tangent --color 255,255,0

 -- Another cool plot: ./plot "LogB(1.5, x)" --color 255,0,0 --tangent -f "LogB(2, x)" --tangent --color 250,136,5 -f "LogB(2.5, x)" --color 255,255,0 --tangent -f "LogB(3, x)" --tangent --color 0,255,0 -f "LogB(3.5, x)" --tangent --color 0,0,255 -f "LogB(4, x)" --color 255,0,255 --tangent --xtick 2.71828182846 --ytick 2.71828182846 --window 1360,720 --xrange -1,10 --yrange -7,6

import ../utils/sdl.egl
import ../utils/misc.egl
import ../utils/math.egl
import ../utils/termargs.egl
import ../arithmetic/lexer.egl
import ../arithmetic/parser.egl
import ../arithmetic/functions.egl
import plot.egl

func main(int argc, byte** argv) : int
{
    srand(time(nil))
    if argc < 2
    {
        printf('Usage: %s -f <expression> [options]\n', argv[0])
        return 0
    }

    WindowInfo winfo
    fill_winfo(&winfo, 640, 480)

    var plot = new Plot(nil, nil)

    var winfo_args = make_winfo_args(&winfo)
    var plot_args  = make_plot_args(plot) 
    var func_args  = make_func_args(plot, &winfo)


    if strequ(argv[1], '--help')
    {
        printf('Usage: %s -f <expression> [options]\n', argv[0])
        puts 'Window Arguments:'
        winfo_args.help()

        puts '\nPlot Arguments:'
        plot_args.help()

        puts '\nFunction Arguments:'
        func_args.help()

        return 0
    }

    -*
    if !strequ(argv[1], '--plot')
    {
        -- TODO: Jump into interactive mode
        return 0
    }
    *-

    winfo_args.run(argv)
    plot_args.run(argv)
    func_args.run(argv)

    SDL_Init(sh_init_everything())
    TTF_Init()

    plot.winfo = &winfo
    plot.surface = new Surface(winfo.width, winfo.height)
    plot.surface.openAsWindow()

    if !winfo.aspect && !winfo.manualy
        plot.resizeWinfo()

    plot.useFont('AnonPro.ttf')
    plot.render()

    if winfo.outfile
        plot.saveToFile(winfo.outfile)

    var event = Event {
        .type = UserEvent
    }

    for event.type != Quit
    {
        wait_event(&event)

        if event.type == MouseMotion
        {
            short x
            event_mouse_coords(&event, &x, nil)
            plot.mouseX = x
            plot.render()
        }
        elif event.type == ActiveEvent -- Called when mouse leaves the window
        {
            plot.mouseX = -1
            plot.render()
        }
    }

    SDL_Quit()

    __dec get_shared_variables() -- Clean up the static variable manually

    return 0
}

func make_winfo_args(WindowInfo* winfo) : TermArgs^
{
    var args = new TermArgs()
    args.rule('--aspect', nil, 'Set X and Y axes on the same scale',
        func(byte* arg, byte* next, bool* skip) {
            arg; next; skip
            winfo.aspect = yes
        })

    args.rule('--window', '--window w,h', 'Set window size; cancels --yrange',
        func(byte* arg, byte* next, bool* skip) {
            arg
            int w
            int h
            sscanf(next, '%d,%d', &w, &h)
            winfo.width = w; winfo.height = h
            skip^ = yes
        })

    args.rule('--xrange', '--xrange min,max', 'Set the X range the plot shows',
        func(byte* arg, byte* next, bool* skip) {
            arg
            double n
            double x
            sscanf(next, '%lf,%lf', &n, &x)
            winfo.xmin = n
            winfo.xmax = x
            skip^ = yes
        })

    args.rule('--yrange', '--yrange min,max', 'Set the Y range the plot shows',
        func(byte* arg, byte* next, bool* skip) {
            arg
            double n
            double x
            sscanf(next, '%lf,%lf', &n, &x)
            winfo.ymin = n
            winfo.ymax = x
            skip^ = yes
        })

    args.rule('--render', '--render outfile', 'Render the plot to a bitmap [outfile]',
        func(byte* arg, byte* next, bool* skip) {
            arg
            winfo.outfile = next
            skip^ = yes
        })

    return args
}

func make_plot_args(Plot^ p) : TermArgs^
{
    var args = new TermArgs()
    args.rule('--axes-color', '--axes-color r,g,b', 'Specify the color for the axes',
        func(byte* arg, byte* next, bool* skip) {
            arg
            read_color(next, &p.axescol)
            skip^ = yes
        })

    args.rule('--bg-color', '--bg-color r,g,b', 'Specify the background color',
        func(byte* arg, byte* next, bool* skip) {
            arg
            read_color(next, &p.backgcol)
            skip^ = yes
        })

    args.rule('--tangent-color', '--tangent-color r,g,b', 'Specify the color of tangent lines',
        func(byte* arg, byte* next, bool* skip) {
            arg
            read_color(next, &p.tancol)
            skip^ = yes
        })

    args.rule('--xtick', '--xtick interval', 'Specify the interval between tick marks on the X axes',
        func(byte* arg, byte* next, bool* skip) {
            arg
            p.xtick = atof(next)
            skip^ = yes
        })

    args.rule('--ytick', '--ytick interval', 'Specify the interval between tick marks on the Y axes',
        func(byte* arg, byte* next, bool* skip) {
            arg
            p.ytick = atof(next)
            skip^ = yes
        })

    return args
}

func make_func_args(Plot^ p, WindowInfo* winfo) : TermArgs^
{
    Function^ cf = nil

    var args = new TermArgs()

    var test_error = func(byte *arg) {
        if !cf
        {
            printf('Error: No function specified for argument %s\n', arg)
            exit(0)
        }
    }

    args.rule('-f', '-f expression', 'Specify a new function with the given expression',
        func(byte* arg, byte* next, bool* skip) {
            arg
            if cf
                p.addFunction(cf)

            cf = new Function(parse(next), winfo)
            skip^ = yes
        })

    args.rule('--color', '--color r,g,b', 'Set the color of the function',
        func(byte* arg, byte* next, bool* skip) {
            test_error(arg)
            read_color(next, &cf.color)
            skip^ = yes
        })

    args.rule('--discreet', nil, 'Plot the function as discreet points',
        func(byte* arg, byte* next, bool* skip) {
            next
            test_error(arg)
            cf.discreet = yes
            skip^ = no
        })

    args.rule('--tangent', nil, 'Draw tangent lines when mousing over function',
        func(byte* arg, byte* next, bool* skip) {
            next
            test_error(arg)
            cf.drawTangents = yes
            skip^ = no
        })

    args.rule('--static', nil, 'Do not draw cross hairs or coordinates for function',
        func(byte* arg, byte* next, bool* skip) {
            next
            test_error(arg)
            cf.ustatic = yes
            skip^ = no
        })

    args.onend = func() {
        if cf
            p.addFunction(cf)
    }

    return args
}

func read_color(byte* fmt, Color* c)
{
    int r
    int g
    int b

    sscanf(fmt, '%d,%d,%d', &r, &g, &b)
    c.r = r
    c.g = g
    c.b = b
}

